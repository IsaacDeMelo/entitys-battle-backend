<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Painel Admin - JSON Editor</title>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; padding: 0; background: #1e1e1e; color: #d4d4d4; font-family: 'Roboto', sans-serif; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        header { background: #2d2d2d; padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #3e3e3e; }
        h1 { margin: 0; font-size: 1.2rem; color: #4ec9b0; }
        
        #editor-container { flex: 1; position: relative; display: flex; }
        
        textarea {
            width: 100%;
            height: 100%;
            background: #1e1e1e;
            color: #d4d4d4;
            border: none;
            padding: 20px;
            font-family: 'Fira Code', monospace;
            font-size: 14px;
            line-height: 1.5;
            resize: none;
            outline: none;
            white-space: pre;
            overflow-y: auto;
        }

        /* Scrollbar estilo VS Code */
        textarea::-webkit-scrollbar { width: 10px; }
        textarea::-webkit-scrollbar-track { background: #1e1e1e; }
        textarea::-webkit-scrollbar-thumb { background: #424242; }
        textarea::-webkit-scrollbar-thumb:hover { background: #4f4f4f; }

        .btn-save {
            background: #0e639c;
            color: white;
            border: none;
            padding: 10px 20px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'Roboto', sans-serif;
            transition: background 0.2s;
        }
        .btn-save:hover { background: #1177bb; }
        .btn-back {
            background: #3c3c3c;
            color: #ccc;
            border: none;
            padding: 10px 15px;
            margin-right: 10px;
            cursor: pointer;
            border-radius: 4px;
            text-decoration: none;
            font-size: 0.9rem;
        }
        .btn-back:hover { background: #4a4a4a; }
        
        /* Bot√£o extra para alternar visualiza√ß√£o */
        .btn-toggle-img {
            background: #3c3c3c;
            color: #dcdcdc;
            border: 1px solid #555;
            padding: 5px 10px;
            margin-right: 15px;
            cursor: pointer;
            font-size: 0.8rem;
            border-radius: 4px;
        }
        .btn-toggle-img:hover { background: #4a4a4a; }

        #status-msg { margin-right: 15px; font-size: 0.9rem; opacity: 0; transition: opacity 0.5s; }
        .success { color: #6a9955; }
        .error { color: #f48771; }
    </style>
</head>
<body>

    <header>
        <div style="display:flex; align-items:center;">
            <a href="/lobby?userId=<%= userId %>" class="btn-back">‚Üê Voltar ao Jogo</a>
            <h1>Database JSON Editor (BasePokemon)</h1>
        </div>
        <div style="display:flex; align-items:center;">
            <!-- Bot√£o opcional para ver as imagens se precisar -->
            <button class="btn-toggle-img" onclick="toggleImages()">üëÅÔ∏è Alternar Imagens</button>
            <span id="status-msg"></span>
            <button class="btn-save" onclick="saveData()">SALVAR ALTERA√á√ïES (SYNC)</button>
        </div>
    </header>

    <div id="editor-container">
        <!-- O valor inicial √© carregado aqui -->
        <textarea id="jsonInput" spellcheck="false"><%= pokemonsJSON %></textarea>
    </div>

    <script>
        const userId = "<%= userId %>";
        const statusEl = document.getElementById('status-msg');
        const textarea = document.getElementById('jsonInput');
        
        // Vari√°vel global para guardar os dados ORIGINAIS (com base64)
        let originalFullData = null;
        const PLACEHOLDER_IMG = "--- IMAGEM BASE64 OCULTA (NAO MEXA AQUI) ---";

        // Inicializa√ß√£o: Ler o textarea, guardar original e limpar a visualiza√ß√£o
        window.onload = function() {
            try {
                const raw = textarea.value;
                if(!raw) return;

                originalFullData = JSON.parse(raw);
                
                // Exibe a vers√£o "limpa"
                textarea.value = JSON.stringify(cleanDataForDisplay(originalFullData), null, 4);
            } catch (e) {
                console.error("Erro ao processar JSON inicial", e);
            }
        };

        // Fun√ß√£o recursiva para substituir strings gigantes por placeholder
        function cleanDataForDisplay(data) {
            // Cria uma c√≥pia profunda para n√£o alterar o original na mem√≥ria
            const copy = JSON.parse(JSON.stringify(data));

            function traverse(obj) {
                for (let key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        // L√≥gica: Se a chave for 'img', 'image' ou o valor for uma string muito longa que parece base64
                        if (typeof obj[key] === 'string') {
                            if (key === 'img' || key === 'image' || (obj[key].startsWith('data:image') && obj[key].length > 100)) {
                                obj[key] = PLACEHOLDER_IMG;
                            }
                        } else if (typeof obj[key] === 'object' && obj[key] !== null) {
                            traverse(obj[key]);
                        }
                    }
                }
            }
            traverse(copy);
            return copy;
        }

        // Fun√ß√£o para restaurar as imagens originais antes de salvar
        function restoreOriginalImages(editedObj, originalObj) {
            // Se o original n√£o existe, retornamos o editado (caso seja um novo pokemon criado do zero)
            if (!originalObj) return editedObj;

            for (let key in editedObj) {
                if (editedObj.hasOwnProperty(key)) {
                    // Se o valor √© o placeholder, restauramos do original
                    if (editedObj[key] === PLACEHOLDER_IMG) {
                        if (originalObj[key]) {
                            editedObj[key] = originalObj[key];
                        }
                    } 
                    // Se for objeto, descemos um n√≠vel (recurs√£o)
                    else if (typeof editedObj[key] === 'object' && editedObj[key] !== null) {
                        // Tenta encontrar o objeto correspondente no original
                        // Nota: Isso assume que a estrutura de arrays/ids se mant√©m relativamente est√°vel
                        // Se voc√™ mudou a ordem de um array, isso pode ser complexo, mas para objetos chave:valor funciona bem.
                        let nextOriginal = (originalObj && originalObj[key]) ? originalObj[key] : null;
                        
                        // Tratamento especial para Arrays se necess√°rio, mas gen√©rico funciona na maioria dos casos
                        // Se for um array de pokemons, precisamos garantir que estamos pegando o item certo pelo ID ou √≠ndice
                        if(Array.isArray(editedObj) && Array.isArray(originalObj)) {
                            // Mapeamento simples por √≠ndice
                             nextOriginal = originalObj[key];
                        }

                        restoreOriginalImages(editedObj[key], nextOriginal);
                    }
                }
            }
            return editedObj;
        }

        // Permitir usar TAB no textarea
        textarea.addEventListener('keydown', function(e) {
            if (e.key == 'Tab') {
                e.preventDefault();
                var start = this.selectionStart;
                var end = this.selectionEnd;
                this.value = this.value.substring(0, start) + "    " + this.value.substring(end);
                this.selectionStart = this.selectionEnd = start + 4;
            }
        });

        // Alternar visualiza√ß√£o (Bot√£o extra)
        let isHidden = true;
        function toggleImages() {
            try {
                const currentVal = JSON.parse(textarea.value);
                if (isHidden) {
                    // Mostrar imagens reais (restaurar temporariamente para visualiza√ß√£o)
                    const full = restoreOriginalImages(currentVal, originalFullData);
                    textarea.value = JSON.stringify(full, null, 4);
                    isHidden = false;
                } else {
                    // Ocultar novamente
                    // Atualiza o originalFullData caso tenha editado algo enquanto via as imagens
                    originalFullData = currentVal; 
                    textarea.value = JSON.stringify(cleanDataForDisplay(currentVal), null, 4);
                    isHidden = true;
                }
            } catch(e) {
                alert("Corrija o erro de sintaxe JSON antes de alternar.");
            }
        }

        async function saveData() {
            const rawDisplayed = textarea.value;
            let finalJsonString = "";
            
            // 1. Valida√ß√£o Sint√°tica
            try {
                let editedData = JSON.parse(rawDisplayed);
                
                // 2. Restaura√ß√£o das Imagens (Merge)
                // Pegamos o que est√° na tela e preenchemos os placeholders com os dados da mem√≥ria
                let finalData = restoreOriginalImages(editedData, originalFullData);
                
                // Atualizamos a mem√≥ria com o estado mais novo (para futuros saves sem reload)
                originalFullData = finalData;
                
                finalJsonString = JSON.stringify(finalData);

            } catch (e) {
                showStatus("Erro de Sintaxe JSON: " + e.message, true);
                return;
            }

            showStatus("Salvando...", false);

            try {
                const res = await fetch('/admin/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        userId: userId,
                        jsonData: finalJsonString // Envia o JSON completo com as imagens
                    })
                });

                const data = await res.json();

                if (data.success) {
                    showStatus(`‚úÖ Sucesso! ${data.count} Pok√©mons processados.`, false);
                    // Opcional: Recarregar a p√°gina ou apenas re-formatar
                    // Se recarregar, perde o undo/redo do navegador, ent√£o talvez melhor s√≥ manter
                    // setTimeout(() => { window.location.reload(); }, 1500); 
                } else {
                    showStatus("‚ùå Erro: " + data.error, true);
                }
            } catch (e) {
                showStatus("‚ùå Erro de conex√£o", true);
                console.error(e);
            }
        }

        function showStatus(msg, isError) {
            statusEl.innerText = msg;
            statusEl.className = isError ? 'error' : 'success';
            statusEl.style.opacity = 1;
            if(!isError && !msg.includes('Salvando')) {
                setTimeout(() => statusEl.style.opacity = 0, 3000);
            }
        }
    </script>
</body>
</html>
